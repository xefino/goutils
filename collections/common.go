package collections

// Keys extracts all the keys from a map and returns them as a slice.
// This function makes no guarantees on ordering
func Keys[T comparable, U any](mapping map[T]U) []T {
	keys := make([]T, 0)
	for key := range mapping {
		keys = append(keys, key)
	}

	return keys
}

// Values extracts all the values from a map and returns them as a slice.
// This function makes no guarantees on ordering
func Values[T comparable, U any](mapping map[T]U) []U {
	values := make([]U, 0)
	for _, value := range mapping {
		values = append(values, value)
	}

	return values
}

// ToDictionary converts a list of items to a map of items based on the output of
// a function that gets a key from each item and a Boolean value that determines
// whether conflicts should be overwritten
func ToDictionary[T any, U comparable](mapping map[U]T, list []T, keyer func(int, T) U, overwrite bool) {
	for i, item := range list {

		// Use the keyer to get a key from the item
		key := keyer(i, item)

		// If the mapping already contains the item then we'll either
		// ignore it, or if overwrite is true, we'll save the item to
		// the map; otherwise, save the item anyway
		if _, ok := mapping[key]; !ok || overwrite {
			mapping[key] = item
		}
	}
}

// ToDictionaryKeys works similarly to the ToDictionary function except that, the list
// provided will be used as the keys and the valuer function will be used to generate a
// value for the map associated with the key. This can be useful when trying to index on
// a struct property
func ToDictionaryKeys[T comparable, U any](mapping map[T]U, list []T, valuer func(int, T) U, overwrite bool) {
	for i, item := range list {

		// Use the keyer to get a key from the item
		value := valuer(i, item)

		// If the mapping already contains the item then we'll either
		// ignore it, or if overwrite is true, we'll save the item to
		// the map; otherwise, save the item anyway
		if _, ok := mapping[item]; !ok || overwrite {
			mapping[item] = value
		}
	}
}

// Index creates an index between the values in a list and their indices
func Index[T comparable](list []T) map[T]int {
	mapping := make(map[T]int)
	ToDictionaryKeys(mapping, list, func(index int, value T) int {
		return index
	}, false)

	return mapping
}

// IndexWithFunction creates an index on a slice of data, where the key is
// generated by the converter function provided, and the value is the index
// of the value that produced the key in the slice
func IndexWithFunction[T any, U comparable](list []T, converter func(T) U) map[U]int {
	mapping := make(map[U]int)
	for i, item := range list {
		key := converter(item)
		mapping[key] = i
	}

	return mapping
}

// AsSlice converts a parameterized list of items to a slice
func AsSlice[T any](data ...T) []T {
	return data
}

// Convert converts all the items in a list from a first type to
// a second type, using the function provided
func Convert[T any, U any](converter func(T) U, data ...T) []U {
	converted := make([]U, len(data))
	for i, item := range data {
		converted[i] = converter(item)
	}

	return converted
}

// ConvertDictionary creates a dictionary from a list using the converter function provided
func ConvertDictionary[T any, U comparable, V any](data []T, converter func(T) (U, V)) map[U]V {
	mapping := make(map[U]V, len(data))
	for _, item := range data {
		key, value := converter(item)
		mapping[key] = value
	}

	return mapping
}

// Contains checks whether or not the value provided exists in list. This
// function will return true if it does, or false if it doesn't
func Contains[T comparable](list []T, value T) bool {
	for _, item := range list {
		if item == value {
			return true
		}
	}

	return false
}

// ContainsFunc checkes whether or not any item in the
func ContainsFunc[T any](list []T, check func(T) bool) bool {
	for _, item := range list {
		if check(item) {
			return true
		}
	}

	return false
}
