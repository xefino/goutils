package collections

// Keys extracts all the keys from a map and returns them as a slice.
// This function makes no guarantees on ordering
func Keys[T comparable, U any](mapping map[T]U) []T {
	keys := make([]T, 0)
	for key := range mapping {
		keys = append(keys, key)
	}

	return keys
}

// Values extracts all the values from a map and returns them as a slice.
// This function makes no guarantees on ordering
func Values[T comparable, U any](mapping map[T]U) []U {
	values := make([]U, 0)
	for _, value := range mapping {
		values = append(values, value)
	}

	return values
}

// ToDictionary converts a list of items to a map of items based on the output of
// a function that gets a key from each item and a Boolean value that determines
// whether conflicts should be overwritten
func ToDictionary[T any, U comparable](mapping map[U]T, list []T, keyer func(int, T) U, overwrite bool) {
	for i, item := range list {

		// Use the keyer to get a key from the item
		key := keyer(i, item)

		// If the mapping already contains the item then we'll either
		// ignore it, or if overwrite is true, we'll save the item to
		// the map; otherwise, save the item anyway
		if _, ok := mapping[key]; !ok || overwrite {
			mapping[key] = item
		}
	}
}

// ToDictionaryKeys works similarly to the ToDictionary function except that, the list
// provided will be used as the keys and the valuer function will be used to generate a
// value for the map associated with the key. This can be useful when trying to index on
// a struct property
func ToDictionaryKeys[T comparable, U any](mapping map[T]U, list []T, valuer func(int, T) U, overwrite bool) {
	for i, item := range list {

		// Use the keyer to get a key from the item
		value := valuer(i, item)

		// If the mapping already contains the item then we'll either
		// ignore it, or if overwrite is true, we'll save the item to
		// the map; otherwise, save the item anyway
		if _, ok := mapping[item]; !ok || overwrite {
			mapping[item] = value
		}
	}
}

// Index creates an index between the values in a list and their indices
func Index[T comparable](list []T) map[T]int {
	mapping := make(map[T]int)
	ToDictionaryKeys(mapping, list, func(index int, value T) int {
		return index
	}, false)

	return mapping
}

// IndexWithFunction creates an index on a slice of data, where the key is
// generated by the converter function provided, and the value is the index
// of the value that produced the key in the slice
func IndexWithFunction[T any, U comparable](list []T, converter func(T) U) map[U]int {
	mapping := make(map[U]int)
	for i, item := range list {
		key := converter(item)
		mapping[key] = i
	}

	return mapping
}

// AsSlice converts a parameterized list of items to a slice
func AsSlice[T any](data ...T) []T {
	return data
}

// Convert converts all the items in a list from a first type to
// a second type, using the function provided
func Convert[T any, U any](converter func(T) U, data ...T) []U {
	converted := make([]U, len(data))
	for i, item := range data {
		converted[i] = converter(item)
	}

	return converted
}

// ConvertFilter converts all the items in a list from a first type to
// a second type and filters the results based on a Boolean flag
func ConvertFilter[T any, U any](converter func(T) (U, bool), data ...T) []U {
	output := make([]U, 0)
	for _, item := range data {
		converted, ok := converter(item)
		if ok {
			output = append(output, converted)
		}
	}

	return output
}

// ConvertDictionary creates a dictionary from a list using the converter function provided
func ConvertDictionary[T any, U comparable, V any](data []T, converter func(T) (U, V)) map[U]V {
	mapping := make(map[U]V, len(data))
	for _, item := range data {
		key, value := converter(item)
		mapping[key] = value
	}

	return mapping
}

// Contains checks whether or not the value provided exists in list. This
// function will return true if it does, or false if it doesn't
func Contains[T comparable](list []T, value T) bool {
	for _, item := range list {
		if item == value {
			return true
		}
	}

	return false
}

// ContainsFunc checkes whether or not any item in the
func ContainsFunc[T any](list []T, check func(T) bool) bool {
	for _, item := range list {
		if check(item) {
			return true
		}
	}

	return false
}

// Page splits a list of values into a paged list-of-lists where each page has the size provided
func Page[T any](list []T, size int) [][]T {
	length := len(list)

	// Calculate the length of the resulting list; add one if we have a partial list
	numResults := length / size
	if length%size != 0 {
		numResults++
	}

	// Fill each page of the results array from the original list
	results := make([][]T, numResults)
	for i := 0; i < numResults; i++ {

		// Get the starting and ending indices of the page; if the end of the page is greater than the
		// length of the initial list then set it to that value
		start := i * size
		end := start + size
		if end > len(list) {
			end = len(list)
		}

		// Extract the sublist and set the value at this index to it
		results[i] = list[start:end]
	}

	// Return the paged array
	return results
}
